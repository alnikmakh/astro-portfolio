---
title: Automate deploy to VPS with Docker and GitHub Actions
publishedAt: 2024-04-20
description: How to use GitHub Actions and Docker to automate deploy
isPublish: true
image: { source: '/public/DALL-E-2024-04-20.webp', description: 'Picture by DALL-E' }
---
import Emphasized from '../../components/shared/emphasized/Emphasized.astro';
export const components = {em: Emphasized};

## Contents

## Introduction

In the [previous article](/posts/01-how-to-run-a-blog-from-scratch-on-vps), we established a setup for our project on a VPS. However, this setup has a significant drawback: every time you need to update your project, you must:

- Commit and push changes to your GitHub repository.
- SSH into your VPS and pull changes from the repository.
- Run docker-compose to build and deploy your new release.

This process involves switching environments and manually running Docker commands on your VPS, which can be cumbersome and slow, especially when deploying urgent fixes. Let's simplify our lives by automating these deployment steps.

## Image to Registry

The first step we'll automate is building and storing the Docker image. Instead of handling this on our VPS, we will set it up to happen automatically in a remote registry using GitHub Actions. GitHub Actions is a feature integrated into GitHub that allows you to run pipelines for your projects. To enable this, create the following directory and file in your project:

```bash
.github/workflows/docker-publish.yml
```

The content of this file should look something like this:

```yml
#
name: Create, publish and deploy

# Configures this workflow to run every time a change is pushed to the branch called `main`.
on:
  push:
    branches: ['main']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.actor }}/astro-blog:latest

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'ci skip')"
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        run: |
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Build and push Docker image
        run: |
          docker build . --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
```

The steps in this YAML file are self-explanatory. I borrowed parts of this file from the one used for this website.

Two important points to note:

- You can skip this entire workflow by simply adding _ci skip_ to your commit message, preventing a rebuild on that particular commit, thanks to this line:

```yml
if: "!contains(github.event.head_commit.message, 'ci skip')"
```

- For the step named _Log in to the Container registry_, you can use a pre-built action from the marketplace, such as [this one](https://github.com/marketplace/actions/docker-login). However, to understand what happens behind the scenes, we've provided a more detailed version. Here, we use ```secrets.GITHUB_TOKEN{:bash}``` to log into the GitHub Container Registry (ghcr.io). This token is automatically generated by GitHub Actions, so you don't need to worry about generating and renewing a Personal Access Token for this use case.

## Deploy

Now that our image is built and stored in the registry, we must still manually pull it on our VPS and instruct Docker to deploy the new container. To automate this, we'll update our ```docker-publish.yml{:bash}``` file to include a new job named _deploy_, which only runs after the _build-and-push-image_ job is complete.

```yml
#
name: Create, publish and deploy

# Configures this workflow to run every time a change is pushed to the branch called `main`.
on:
  push:
    branches: ['main']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.actor }}/astro-blog:latest

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'ci skip')"
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        run: |
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Build and push Docker image
        run: |
          docker build . --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
  deploy:
    needs: build-and-push-image
    name: deploy image
    runs-on: ubuntu-latest

    steps:
      - name: install ssh keys
        # check this thread to understand why its needed:
        # <https://stackoverflow.com/a/70447517>
        run: |
          install -m 600 -D /dev/null ~/.ssh/gthb_ctn
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/gthb_ctn
          ssh-keyscan -H ${{ secrets.SSH_HOST }} > ~/.ssh/known_hosts
      - name: connect and pull
        run: ssh -i ~/.ssh/gthb_ctn ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "cd ${{ secrets.WORK_DIR }} && docker compose pull && docker compose up -d && exit"
      - name: cleanup
        run: rm -rf ~/.ssh
```

This job will require several secrets to be added to your repository:

- _SSH_PRIVATE_KEY_: the private part of your SSH key.
- _SSH_USER_: the username for the user on your VPS.
- _SSH_HOST_: the address of your VPS.
- _WORK_DIR_: the directory containing ```docker-compose.yml{:bash}``` for deploying your project.

### SSH Private Key

It's crucial that the GitHub Actions worker logs into your VPS without a password. Hereâ€™s how to set it up:

- Generate SSH keys on your _local_ machine.
- Add your _public_ key to ```.ssh/authorized_keys{:bash}``` on your VPS.
- Use the _private_ key in your GitHub Actions setup, as already done in our ```docker-publish.yml{:bash}```.

For more details on SSH key setup, refer to [this article](http://www.linuxproblem.org/art_9.html).

## Docker Compose

Our GitHub Actions workflow is almost ready. The final step is to adjust ```docker-compose.yml{:bash}``` from our [previous article](/posts/01-how-to-run-a-blog-from-scratch-on-vps) to no longer build from the source code on the VPS:

```diff
frontend:
-  build: .
+  image: <path.to/image/in:registry>
  container_name: frontend
  env_file:
    - hosts.env
```

Instead, we specify in the Docker Compose file to pull the image from the registry, where it was pushed by the ```docker push{:yml}``` command during the GitHub Actions workflow.

## Conclusion

That's it! Now, whenever you push changes to the _'main'_ branch without the _'ci skip'_ in the commit message, the GitHub Actions workflow will start. It will build a new image from your source code, push it to the registry, log into your VPS, navigate to the working directory with ```docker-compose.yml{:bash}```, and redeploy the containers.
